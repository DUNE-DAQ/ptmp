#+title: PTMP

Prototype Trigger Message Passing aka Pretty Temporary

* Introduction 

This package provides trigger messages transport for the protoDUNE DAQ
prototyping development toward full DUNE Far Detector DAQ.

A simple API is provided which hides details of the transport
mechanism.  The application simply sees a sink or a source of trigger
messages.  Driven by user configuration, an intervening network may be
defined.  This can be a simple sink-to-source pipeline or may be
structured into a rich data flow network which may include redundant
flow paths and intervening filtering/processing with redundancy and
load balancing.  The sink/source applications need not be complicated by this richness.

Message transport is based on ZeroMQ which provides robustness and
performance (see the section on throughput performance in the [[./docs/tuning.org][tuning]]
document).  Thus, the PTMP network may exist over a mix of transports
(inter-thread, inter-process and inter-computer) as determined by the
configuration.  The payload message frames are currently serialized
using protobuf ([[./ptmp/ptmp.proto][schema]]).


* Status

This package has basic functionality.  See [[./docs/todo.org][To Do]] document for checklist
and notes on future development. 

This button determines if recent builds and tests pass on Travis-CI:

[[https://travis-ci.org/brettviren/ptmp][file:https://travis-ci.org/brettviren/ptmp.svg]]

Note, a failure here is not necessarily indicative of a real problem.

* Installation 

The PTMP package should build with any reasonably up to date C++
compiler.  GCC 7 is used in development.  Prerequisite software
dependencies are:

- libzmq
- CZMQ
- protobuf (v2)

See the [[./.travis.yml][Travis-CI file]] for an ~apt~ installation line.  There is also a
[[./installdeps.sh][script]] to assist building the dependencies from source.  With
prerequisites available, issue:

#+BEGIN_EXAMPLE
  $ ./waf --prefix=<path> configure build install
  $ ls <path>/{lib,include,bin}/
#+END_EXAMPLE 

Replace ~<path>~ with a into which you want the software to install.  If
you want to just test it locally you may omit ~--prefix~ and the ~install~
command.

As part of the build, a number of tests will be built and run.  See
the [[./docs/tuning.org][tuning]] document for some details on these tests.

* Application Development

Application may be a "sender" or a "receiver" of trigger messages by
instantiating a ~TPSender~ or ~TPReceiver~, respectively, with their
configuration string.  These instances should be long-lived.  They are
/callable/ objects.  The sender will take a ~const TPSet&~ to read and
send to the network as a single message and the receiver takes a
non-const ~TPSet&~ to be filled when a message arrives.  The receiver
also takes an optional second argument which is a timeout in msec.  If
no message arrives w/in that time the call will return the value
~false~.  The receiver may ~throw std::runtime_error~ if a message is
received which can not be deserialized into the ~TPSet~ object.

The following applications provide reference applications.  Running
them without command line arguments will give a usage message.

- [[./test/check_send.cc][check_send]] :: send empty ~TPSet~ via ~ipc~ or ~tcp~ in a simple manner.
- [[./test/check_send.cc][check_send_rates]] :: a more sophisticated version of the above which
     adds a model for inter-message timing variability as well as
     filling ~TPSet~ with some number of actual TPs.
- [[./test/check_recv.cc][check_recv]] :: receive messages via ~ipc~ or ~tcp~.  Works with either senders.
- [[./test/check_sendrecv.cc][check_sendrecv]] :: a self contained sender+receiver that can use
     ~inproc~ as well as ~ipc~ or ~tcp~.

Application programmers (and possibly their users) should also read
the section [[Configuration]] below.

* Actor Development 

*note: support for actors is a work in progress*

The low level API described above may be all that an developer chooses to use.  However, PTMP supports a more flexible and simpler programming interface which is based on CZMQ's /actor/ pattern.  The programmer provides functionality through a single function (a [[http://czmq.zeromq.org/manual:zactor][CZMQ ~zactor~ function]]).  This pattern provides two main benefits:

1) as actors operate in a well defined context the developer can focus on core functionality.
2) the resulting functionality can then later be composed with other actors through configuration to build a rich application. 

The actor function is called by PTMP inside its own thread and passed two arguments: a PAIR socket called the "pipe" and a ~void*~ which is used to pass initial configuration in the form of a ~const char*~ in JSON format are passed into the actor function.  Once called, the actor function must participate in the /PTMP actor protocol/ but otherwise is free to do whatever the developer requires.  Likewise, a portion of the JSON schema is standardized but the developer may extend it to suit the needs of the actor program.

Participating in the PTMP actor protocol entails expecting and providing certain message types on the pipe.  The protocol is largely asynchronous (ie, not query/response aka client/server patterns).  The protocol begins with the actor sending an empty "signal" message:

#+BEGIN_SRC c++
    zsock_signal(pipe, 0);      // ready
#+END_SRC

All subsequent messages are /multipart/ (have multiple frames).  The
first frame carries an integer (an enum in ~ptmp::actor::~ namespace)
marking the message /type/.  Subsequent frames may be provided on a
type-specific basis.  The types are enumerated as:

- ~ptmp::actor::stop~ :: no additional frames.  An actor
       shall send this prior to existing the function.  PTMP shall
       send this requesting the actor terminate and prior to
       destroying the actor.

- ~ptmp::actor::config~ :: the second frame shall contain a
       character string in JSON format.  A ~config~ message may be sent
       to the actor which may then reconfigure itself based on the
       contents.  A ~config~ message may be sent from the actor with the
       intention that it reports its current configuration state.  The
       schema of this message is partly standardized, as described
       below, but may be extended to suit the needs of the actor.

- ~ptmp::actor::create~ :: the second frame shall contain an actor
     configuration string.  Received by PTMP, it will attempt to
     create an actor as described by the configuration string.

- ~ptmp::actor::destroy~ ::  the second frame shall contain an actor
     configuration string.  Received by PTMP, it will attempt to
     destroy a previously created actor as described by the
     configuration string.



* Configuration

The PTMP API classes and PTMP actors are configured through JSON.  In
both cases, the top level schema is that of a JSON object.  The
details of this schema are described.

** API Schema

To configure an API class (~TPSender~ or ~TPReceiver~) the JSON object
must contain a ~socket~ attribute which is itself an object with the
following attributes:

- type :: a ZeroMQ socket type name ("PAIR", "PUB", "SUB", etc)
- bind :: an array of addresses in canonical ZeroMQ form that the socket should bind
- connect :: an array of addresses in canonical ZeroMQ form that the socket should connect

The usual ZeroMQ restrictions apply.  For example a PAIR socket may
only bind or connect to one address.  Others can bind or connect to
multiple addresses.

** Actor schema

*note: support for actors is a work in progress*

The actor schema governs JSON objects which are used for creating an
actor, providing its initial configuration string, providing
subsequent configuration updates, reporting its current configuration
by an actor and destroying the actor.  Which of the attributes
described below are used depends on which action is being taken.

- name :: a string which shall uniquely identify the actor instance.
          The context of uniqueness shall be at least over all actors
          of the PTMP application implemented with the given ~function~
          (see next).

- function :: the actor function name.

- datatime :: a time value measured in the "data clock" at which the
              configuration should be considered applied.  If absent
              the configuration should be considered immediate.

- sockets :: an array of objects of type ~socket~ as described above.
             These are intended to describe sockets which the actor
             produces but shall exclude the pipe.  An actor should
             apply this attribute when creating and configuring
             sockets and shall provide it to reflect the configuration
             of any sockets that need be known by others.

- etc :: other attributes may be included on a per function basis.
         These may be ignored by PTMP but shall be forwarded to the
         actor pipe where applicable.


* Tuning and Exception Handling

The document [[./docs/tuning.org][tuning]] collects some information that will help
understand how the PTMP network behaves, where things can be tuned to
meet different goals and also some known features of a high
performance, asynchronous communication network that are best taken
into account.

